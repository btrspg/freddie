#!/usr/bin/env python3
import argparse
from os import listdir

import numpy as np
import matplotlib.pyplot as plt

def parse_args():
    parser = argparse.ArgumentParser(
        description="Cluster aligned reads into isoforms")
    parser.add_argument("-a",
                        "--annotation-gtf",
                        type=str,
                        required=True,
                        help="Path to GTF file of annotations")
    parser.add_argument("-r",
                        "--reads",
                        nargs="+",
                        type=str,
                        required=True,
                        help="Space separated paths to reads in FASTQ or FASTA format")
    parser.add_argument("-sd",
                        "--seqpare-dir",
                        type=str,
                        required=True,
                        help="Path to seqpare dir generated by Freddie")
    parser.add_argument("-st",
                        "--similarity-threshold",
                        type=float,
                        default=0.5,
                        help="Mininum required similary to match a pair. Default: 0.5")
    parser.add_argument("-c",
                        "--min-cov",
                        type=int,
                        default=5,
                        help="Mininum coverage to not discard a transcript. Default: 3")
    parser.add_argument("-o",
                        "--output",
                        type=str,
                        default='freddie_similarity.txt',
                        help="Output file. Default: freddie_similarity.txt")
    args = parser.parse_args()
    return args

def plot_heatmap(old_A, iids, old_tids, tint, tid_cov, min_cov, prefix):
    low_cov_tids_idxs = list()
    tids = list()
    for idx,tid in enumerate(old_tids):
        if tid_cov.get(tid.split(':')[-1], 0)<min_cov:
            low_cov_tids_idxs.append(idx)
        else:
            tids.append(tid)
    A = np.delete(old_A,low_cov_tids_idxs,axis=1)
    if min(A.shape)==0:
        return
    fig, ax = plt.subplots(figsize=(30,20))
    im = ax.imshow(A, cmap=plt.get_cmap('Greys'),vmin=0.0, vmax=1.0)

    ax.set_xticks(np.arange(A.shape[1]))
    ax.set_yticks(np.arange(A.shape[0]))
    ax.set_xticklabels(tids)
    ax.set_yticklabels(iids)
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")

    print(len(iids),len(tids),A.shape)
    for j in range(len(tids)):
            for i in range(len(iids)):
                text = ax.text(j, i, '{:2.2f}%'.format(A[i, j]*100), ha="center", va="center", color='w')

    ax.set_title("Predicted vs ground truth for tint {}".format(tint))
    fig.tight_layout()
    plt.savefig('{}{}.png'.format(prefix,tint))

def get_tid_to_tid(gtf):
    tid_to_tid = dict()
    c=0
    for line in open(gtf):
        if line[0]=='#':
            continue
        line = line.rstrip().split('\t')
        if line[2]!='transcript':
            continue
        c+=1
        info = {x.strip().split()[0]:x.strip().split()[1].strip('"') for x in line[8].rstrip(';').split(';')}
        assert not info['transcript_id'] in tid_to_tid
        tid_to_tid[info['transcript_id']] = info['transcript_name']
    assert len(set(tid_to_tid.values()))==len(tid_to_tid)==c
    return tid_to_tid

def get_pairings(seqpare_dir,sim_threshold, tid_cov, min_cov):
    pairings = list()
    unpaired_iids = list()
    unpaired_tids = list()
    iid_above_sim = dict()
    tid_above_sim = dict()
    for tint in listdir(seqpare_dir):
        tint=tint.split('.')
        if not (len(tint)==2 and tint[0].isdigit() and tint[1]=='tsv'):
            continue
        tint=int(tint[0])
        tids = set()
        iids = set()
        A = dict()
        for line in open('{}/{}.tsv'.format(seqpare_dir,tint)):
            line = line.rstrip().split('\t')
            if len(line)==2:
                iid = '{}:{}'.format(tint,line[0].rstrip('.bed'))
                tid = '{}:{}'.format(tint,line[1].rstrip('.bed'))
                iids.add(iid)
                tids.add(tid)
            elif len(line)==4:
                N1 = int(line[0])
                N2 = int(line[1])
                O = float(line[2])
                S = O/(N1+N2-O)
                assert not (iid,tid) in A
                A[(iid,tid)]=S
        for x in [tids,iids]:
            x -= {'{}:*'.format(tint)}
        assert len(A)==len(tids)*len(iids), (A,tid,iids)
        iids = sorted(iids)
        tids = sorted(tids)
        for iid in iids:
            iid_above_sim[iid]=0
        for tid in tids:
            tid_above_sim[tid]=0
        for (iid,tid),s in A.items():
            if s > sim_threshold:
                iid_above_sim[iid]+=1
                tid_above_sim[tid]+=1
        A = np.array([v for k,v in sorted(A.items())]).reshape((len(iids),len(tids)))
        plot_heatmap(A, iids, tids, tint, tid_cov, min_cov, seqpare_dir)
        # print('\n'.join('{:2d}:{}'.format(idx,tid) for idx,tid in enumerate(tids)))
        # print('\t'.join(['\\']+list(map(str,range(len(tids))))))
        # for idx in range(A.shape[0]):
        #     print('\t'.join([iids[idx]]+['{:5.2f}%'.format(s*100) for s in A[idx]]))
        while min(A.shape)>0:
            iidx,tidx = np.unravel_index(A.argmax(), A.shape)
            iid=iids[iidx]
            tid=tids[tidx]
            iids.remove(iid)
            tids.remove(tid)
            if A[iidx,tidx]>sim_threshold:
                pairings.append((A[iidx,tidx],iid,tid))
            else:
                unpaired_iids.append(iid)
                unpaired_tids.append(tid)
            A=np.delete(A,iidx, axis=0)
            A=np.delete(A,tidx, axis=1)
        unpaired_iids.extend(iids)
        unpaired_tids.extend(tids)
    return pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim


def get_tid_cov(read_files, tid_to_tid):
    tid_cov = dict()
    for reads in read_files:
        for line in open(reads):
            if line[0] != '@':
                continue
            tid=line[1:].split()[0].split('_')[0]
            if not tid in tid_to_tid:
                continue
            tid=tid_to_tid[tid]
            tid_cov[tid] = tid_cov.get(tid, 0) + 1
    return tid_cov

def print_unpaired_stats(outfile, name, unpaired, above_sim):
    print('Unpaired {} # = {},\n\tof which {} have at least one match,\n\tmed= {:2.2f},\n\tmean = {:2.2f},\n\tstd = {:2.2f}'.format(
        name,
        len(unpaired),
        len([i for i in unpaired if above_sim[i]>0]),
        np.median([above_sim[i] for i in unpaired]),
        np.mean([above_sim[i] for i in unpaired]),
        np.std([above_sim[i] for i in unpaired]),
    ), file=outfile)

def print_stats(outfile, pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim):
    print('Pairings # = {},\n\tmed = {:2.2f}%,\n\tmean = {:2.2f}%,\n\tstd = {:2.2f}%'.format(
        len(pairings),
        100*np.median([x[0] for x in pairings]),
        100*np.mean([x[0] for x in pairings]),
        100*np.std([x[0] for x in pairings]),
    ), file=outfile)
    print_unpaired_stats(outfile, 'iid', unpaired_iids, iid_above_sim)
    print_unpaired_stats(outfile, 'tid', unpaired_tids, tid_above_sim)

def output_similarity(outpath, pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim, min_cov, tid_cov):
    outfile = open(outpath, 'w+')
    print_stats(outfile, pairings, unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim)
    for s,iid,tid in pairings:
        print('{}\t{}\t{:2.2f}%'.format(tid,iid,s*100))
    # for s,iid,tid in pairings:
    #     if tid_cov.get(tid,0) < min_cov:
    #         pairings.remove((s,iid,tid))
    #         unpaired_iids.append(iid)
    # for tid in unpaired_tids:
    #     if tid_cov.get(tid,0) < min_cov:
    #         unpaired_tids.remove(tid)
    # print('\nIf we remove transcripts with coverage < {}'.format(min_cov), file=outfile)
    # print_stats(outfile, pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim)
    outfile.close()

def main():
    args = parse_args()
    tid_to_tid = get_tid_to_tid(args.annotation_gtf)
    tid_cov = get_tid_cov(args.reads, tid_to_tid)
    pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim = get_pairings(args.seqpare_dir, args.similarity_threshold, tid_cov, args.min_cov)
    output_similarity(args.output, pairings,unpaired_iids,unpaired_tids,iid_above_sim,tid_above_sim, args.min_cov, tid_cov)


if __name__ == "__main__":
    main()
