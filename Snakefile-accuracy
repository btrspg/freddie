import os
configfile: 'config.yaml'

configfile: 'config.yaml'
localrules:
    all,
    cat_edges_tsv,

for k in config.keys():
    if not k.startswith('override_'):
        continue
    keys = k[len('override_'):].split('_')
    top_dict = eval('config{}'.format(''.join(['["{}"]'.format(x) for x in keys[:-1]])))
    assert keys[-1] in top_dict
    top_dict[keys[-1]]=config[k]

def make_slurm():
    os.makedirs('slurm'.format(outpath), mode=0o777, exist_ok=True)

def get_which(command):
    result = subprocess.run(['which', command], stdout=subprocess.PIPE)
    return result.stdout.decode('ascii').rstrip()

outpath      = config['outpath'].rstrip('/')
preprocess_d = '{}/preprocess'.format(outpath)
workspace_d  = '{}/workspace'.format(outpath)
output_d     = '{}/output'.format(outpath)
graphs_d     = '{}/graphs'.format(outpath)
plots_d      = '{}/plots'.format(outpath)


simu_tools = ['truth', 'isoform', 'genome', 'segment']
real_tools = ['troth']
for tool in config['tools']:
    if tool == 'flair':
        for r in config['gtf_sample_rates']:
            simu_tools.append('flair.{:.2f}'.format(r))
            real_tools.append('flair.{:.2f}'.format(r))
    else:
        simu_tools.append(tool)
        real_tools.append(tool)

overlaps = dict()
for s in config['samples']:
    overlaps[s]=dict()
    for m in config['mappers']:
        overlaps[s][m]=dict()
        if config['samples'][s]['reads_info'] == 0:
            tools = real_tools
        else:
            tools = simu_tools
        for t in tools:
            overlaps[s][m][t] = dict()
            for l in open('{}/{}/{}/{}.overlaps.tsv'.format(graphs_d, s, m, t)):
                c,i1,i2 = l.rstrip().split('\t')
                if i1==i2:
                    continue
                if not c in overlaps[s][m][t]:
                    overlaps[s][m][t][c]=dict()
                if i1.startswith(t) and i2.startswith(t):
                    i1,i2 = sorted((i1,i2))
                overlaps[s][m][t][c][i1] = overlaps[s][m][t][c].get(i1, set()) | {i2}


rule all:
    input:
        [
            '{p}/{s}/{m}/{t}.alignments/{c}.{f}'.format(
                p=graphs_d,
                s=s,
                m=m,
                t=t,
                c=c,
                f=f,
            )
            for f in ['edges.tsv', 'jobs']
                for s in overlaps 
                    for m in overlaps[s] 
                        for t in overlaps[s][m]
                            for c in overlaps[s][m][t]
        ],
        [
            '{p}/{s}/{m}/{t}.edges.tsv'.format(
                p=graphs_d,
                s=s,
                m=m,
                t=t,
            )
            for s in overlaps 
                for m in overlaps[s] 
                    for t in overlaps[s][m]
        ],
        [
            '{p}/{s}/{m}'.format(
                p=plots_d,
                s=s,
                m=m,
                t=t,
            )
            for s in overlaps 
                for m in overlaps[s] 
        ],


rule align_to_transcript_jobs:
    input:
        direct = '{}/{{sample}}/{{mapper}}/{{tool}}.transcripts/{{contig}}'.format(graphs_d),
    output:
        jobs   = '{}/{{sample}}/{{mapper}}/{{tool}}.alignments/{{contig}}.jobs'.format(graphs_d),
    run:
        s = wildcards.sample
        m = wildcards.mapper
        t = wildcards.tool
        c = wildcards.contig
        target_tmpl = '{p}/{s}/{m}/{t}.transcripts/{c}/{{i1}}.fa'.format(
            p=graphs_d,
            s=s,
            m=m,
            t=t,
            c=c,
        )
        query_tmpl  = '{p}/{s}/{m}/{{qt}}.transcripts/{c}/{{i2}}.fa'.format(
            p=graphs_d,
            s=s,
            m=m,
            t=t,
            c=c,
        )
        jobs = open(output.jobs, 'w+')
        for i1,i2s in overlaps[s][m][t][c].items():
            target = target_tmpl.format(i1=i1)
            for i2 in i2s:
                query = query_tmpl.format(qt=i2.split('_')[0], i2=i2)
                jobs.write(
                    'minimap2 -t 1 --splice {} {} 2> /dev/null | grep "tp:A:P" | sort -k10,10nr | awk \'BEGIN{{OFS=\"\\t\"}} NR==1 {{print $1,$6,$10/(($2+$7)/2)}}\'\n'.format(
                        target,
                        query,
                    )
                )
rule edges_tsv:
    input:
        jobs = '{}/{{sample}}/{{mapper}}/{{tool}}.alignments/{{contig}}.jobs'.format(graphs_d),
    output:
        cons = '{}/{{sample}}/{{mapper}}/{{tool}}.alignments/{{contig}}.edges.tsv'.format(graphs_d),
    resources:
        mem_mb = 32*1024,
        time   = 60*24-1,
    conda:
        'envs/accuracy.yml'
    threads:
        32
    shell:
        'parallel --jobs {threads} < {input.jobs} > {output.cons}'


rule cat_edges_tsv:
    input:
        lambda wildcards: ['{}/{{sample}}/{{mapper}}/{{tool}}.alignments/{}.edges.tsv'.format(graphs_d, c)
            for c in overlaps[wildcards.sample][wildcards.mapper][wildcards.tool]
        ],
    output:
        '{}/{{sample}}/{{mapper}}/{{tool}}.edges.tsv'.format(graphs_d),
    shell:
        'cat {input} > {output}'

rule accuracy_plots:
    input:
        script = 'py/freddie_accuracy.py',
        graphs = lambda wildcards: [
            '{}/{}/{}/{}.edges.tsv'.format(graphs_d, wildcards.sample, wildcards.mapper, t)
            for t in overlaps[wildcards.sample][wildcards.mapper]
        ],
    conda:
        'envs/accuracy.yml'
    output:
        direct = directory('{}/{{sample}}/{{mapper}}'.format(plots_d)),
    params:
        in_direct = '{}/{{sample}}/{{mapper}}'.format(graphs_d),
    shell:
        '{input.script} -id {params.in_direct} -od {output.direct}'